/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2019 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */
#include <stdint.h>
#include "InputCapture.h"

Gpio_t *gpioC = (Gpio_t *)GPIOC_ADDR;
Tim_t *Tim2 = (Tim_t *)TIM_ADDR;
Gpio_t *gpioA = (Gpio_t *)GPIOA_ADDR;
#define NVIC 0xE000E100
#define pulse 0xf
#define LSEON 1
#define LSERDY 2
int main(void)
{
	uint32_t *Rcc_cfgr = (uint32_t *)RCC_CFGR;
	uint32_t *pwr_cr1 = (uint32_t *)PWR;
	uint32_t *Rcc1 = (uint32_t *)RCC_ENGPIO_ADDR;
	uint32_t *Rcc2 = (uint32_t *)RCC_ENTIM2_ADDR;
	uint32_t *Rcc_Bdcr = (uint32_t *)RCC_ADDR_BDCR;

	//Enable gpioA
	*Rcc1 |= 1<<17;
    // Enable tim2 and pwr
	*Rcc2 |= (1 | (1<<28));
    // Enable RTC domain write protection
	*pwr_cr1= 1<<8;

	// Enable lse and wait for it to get ready
	*Rcc_Bdcr |= LSEON;
	while((*Rcc_Bdcr & LSERDY) == LSERDY);

	gpioA->mode &= ~(0x3);
	// TIM2 PIN MODE
	gpioA->mode |= 2;
	// MCO PINMODE PA8
	gpioA->mode |= (2<<16);
	// AF2 pa0
	gpioA->afrl |= 2;
	// AF0 PA8
	gpioA->afrh &= ~(0xf);

	// Set MCO as LSE
	*Rcc_cfgr &= ~(0xf<<24);
	*Rcc_cfgr |= (0x3<<24) | (0x1<<28);

	while(1);
}
//while(1){
//void TIM2_IRQHandler(void)
//{
////	if((Tim2->SR & 2) == 2)
////	{
// 		Tim2->SR &= ~(3);
////		gpioC->odr ^= (1<<6);
////		Tim2->CCR1 = (Tim2->CCR1 +pulse);
////		if(Tim2->CCR1 > 0xff)
////		{
////			Tim2->CCR1 = pulse;
////		}
////////		gpioA->odr ^/= (1);
////	}
//}

